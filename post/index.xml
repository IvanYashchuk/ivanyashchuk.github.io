<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Ivan Yashchuk</title>
    <link>https://ivanyashchuk.github.io/post/index.xml</link>
    <description>Recent content in Posts on Ivan Yashchuk</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 07 Aug 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://ivanyashchuk.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Weak scaling</title>
      <link>https://ivanyashchuk.github.io/post/weak-scaling/</link>
      <pubDate>Mon, 07 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ivanyashchuk.github.io/post/weak-scaling/</guid>
      <description>&lt;p&gt;Good news that parallel solving in DOLFIN for quadrilateral and hexahedral mesh worked &amp;ldquo;out-of-the-box&amp;rdquo; with the changes made to FFC and FIAT.
Now it is needed to see how well it performs.&lt;/p&gt;

&lt;p&gt;Weak scaling test shows how the solution time varies with the number of processors for a fixed problem size per processor.
I&amp;rsquo;ve adapted Chris&amp;rsquo;s demo &lt;a href=&#34;https://bitbucket.org/chris_richardson/weak-scaling-demo&#34;&gt;https://bitbucket.org/chris_richardson/weak-scaling-demo&lt;/a&gt; for hex mesh.&lt;/p&gt;

&lt;p&gt;Here are the results:
&lt;img src=&#34;https://lh5.googleusercontent.com/fhL9TRftKpKNOtv1pRDgS5tvA2Hem8vfeK7Qaxkj5m0-Jxgy-ZdULHln_x8I3q9Bcd-q9kMN&#34;&gt;&lt;/p&gt;

&lt;p&gt;It is seen from the plot that assembly and defining function space takes roughly the same time when increasing number of processes.
For solving &lt;code&gt;hypre-amg&lt;/code&gt; was used and the results show that hex solution does not scale that well. The reasons are still need to be discovered.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Second evaluation is passed!</title>
      <link>https://ivanyashchuk.github.io/post/second-evaluation/</link>
      <pubDate>Sun, 30 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ivanyashchuk.github.io/post/second-evaluation/</guid>
      <description>&lt;p&gt;This week was the second evaluation week, which was passed successfully!
During this month I&amp;rsquo;ve added new reference cells (&lt;code&gt;UFCQuadrilateral&lt;/code&gt; and &lt;code&gt;UFCHexahedron&lt;/code&gt;) to FIAT as well as the new wrapper class which defines
&lt;code&gt;TensorProductElement&lt;/code&gt; on new reference cells. Changes to DOLFIN and FFC were added so the definition of quadrilateral and hexahedron cells is the same across FEniCS.
Solving Poisson equation works both for quadrilateral and hexahedral mesh now!&lt;/p&gt;

&lt;p&gt;Plan for the future:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Find functionality that is not working with quadrilateral and hexahedral cells.&lt;/li&gt;
&lt;li&gt;Add unit tests.&lt;/li&gt;
&lt;li&gt;Add regression tests.&lt;/li&gt;
&lt;li&gt;Documented demos.&lt;/li&gt;
&lt;li&gt;Serial and parallel perfomance testing.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Meet new class for FIAT!</title>
      <link>https://ivanyashchuk.github.io/post/meet-new-class-for-FIAT/</link>
      <pubDate>Fri, 21 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ivanyashchuk.github.io/post/meet-new-class-for-FIAT/</guid>
      <description>&lt;p&gt;FIAT (FInite element Automatic Tabulator) is a Python package for
defining and evaluating a wide range of different finite element basis
functions for numerical partial differential equations.&lt;/p&gt;

&lt;p&gt;FIAT uses a object-oriented infrastructure to define
finite elements.  For example, the &lt;code&gt;Lagrange&lt;/code&gt; module contains a class
&lt;code&gt;Lagrange&lt;/code&gt; modeling the Lagrange finite element family.  This
class is a subclass of some &lt;code&gt;FiniteElement&lt;/code&gt; class contained in
another module.&lt;/p&gt;

&lt;p&gt;FIAT has &lt;code&gt;TensorProductElement&lt;/code&gt; class to define products of other elements.
Lagrangian finite element defined on a quadrilateral cell is a tensor product of two Lagrange elements defined on intervals.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from FIAT.tensor_product import TensorProductElement
from FIAT.lagrange import Lagrange
from FIAT.reference_element import UFCInterval as interval
quadrilateral_element = TensorProductElement(Lagrange(interval()), Lagrange(interval()))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, as discussed in the previous post this element has tuple structure for dimensions as it is defined on a &lt;code&gt;TensorProductCell&lt;/code&gt;
Therefore it needs to be changed so that it is defined on new &lt;code&gt;UFCHexahedron&lt;/code&gt; and &lt;code&gt;UFCQuadrilateral&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Newly implemented wrapper class &lt;code&gt;FlattenedDimensions&lt;/code&gt; does that.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;from FIAT.tensor_product import TensorProductElement, FlattenedDimensions
from FIAT.lagrange import Lagrange
from FIAT.reference_element import UFCInterval as interval
quadrilateral_element = FlattenedDimensions(TensorProductElement(Lagrange(interval()), Lagrange(interval())))
```&lt;/p&gt;

&lt;p&gt;Now &lt;code&gt;quadrilateral_element&lt;/code&gt; is defined on UFCQuadrilateral and can be easily used by FFC to generate C++ code for assembling matrices.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About numbering of mesh entities</title>
      <link>https://ivanyashchuk.github.io/post/numbering-of-mesh-entities/</link>
      <pubDate>Wed, 12 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ivanyashchuk.github.io/post/numbering-of-mesh-entities/</guid>
      <description>&lt;p&gt;The topological entities of a cell (or mesh) are referred to as mesh entities.
A mesh entity can be identified by a pair $(d, i)$, where $d$ is the topological
dimension of the mesh entity and $i$ is a unique index of the mesh entity. Mesh
entities are numbered within each topological dimension from $0$ to $n_d − 1$,
where $n_d$ is the number of mesh entities of topological dimension $d$.
Mesh entity numbering should be the same across all software components (FIAT, FFC, DOLFIN).&lt;/p&gt;

&lt;p&gt;Quadrilateral and hexahedron cells are constructed as &lt;code&gt;FIAT.reference_element.TensorProductCell&lt;/code&gt; of interval cells.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from fenics import *
from ffc.fiatinterface import create_element
# Create UFL&#39;s P1 Finite Element on interval
ufl_interval = FiniteElement(&amp;quot;P&amp;quot;, interval, 1)

# Create FIAT&#39;s Finite Element on interval
fiat_interval = create_element(ufl_interval)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;code&gt;fiat_interval&lt;/code&gt; is instance of &lt;code&gt;FIAT.Lagrange&lt;/code&gt; on reference element &lt;code&gt;UFCInterval&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;In [..]: fiat_interval.get_reference_element()
Out[..]: &amp;lt;FIAT.reference_element.UFCInterval at 0x7fdb4aa72da0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The topological entities of a cell can accessed with &lt;code&gt;reference_element.get_topology()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;In [..]: fiat_interval.ref_el.get_topology()
Out[..]: {0: {0: (0,), 1: (1,)}, 1: {0: (0, 1)}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Topology of a cell is stored as dict of dicts, mesh entity identified by a pair $(d, i)$ can accessed by index &lt;code&gt;[d][i]&lt;/code&gt;.
Entities of topological dimension 0 here are vertices, entities of dimension 1 (codimension zero) is the cell itself.&lt;/p&gt;

&lt;p&gt;Quadrilateral is &lt;code&gt;TensorProductCell(UFCInterval(), UFCInterval())&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from FIAT.reference_element import TensorProductCell, UFCInterval
quad_cell = TensorProductCell(UFCInterval(), UFCInterval())
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;In [..]: quad_cell.get_topology()
Out[..]:
{(0, 0): {0: (0,), 1: (1,), 2: (2,), 3: (3,)},
 (0, 1): {0: (0, 1), 1: (2, 3)},
 (1, 0): {0: (0, 2), 1: (1, 3)},
 (1, 1): {0: (0, 1, 2, 3)}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now topological dimension is stored as the tuple of dimensions in different &amp;ldquo;directions&amp;rdquo;, it comes from the tensor product operation.
The topological dimension $d$ is the sum of the elements in the tuple.
It is useful to store the dimension as a tuple if interval elements of different order are used in different directions. Usually the order is the same.&lt;/p&gt;

&lt;p&gt;It is more practical to store the dimension as an integer. Therefore new FIAT&amp;rsquo;s reference cell were introduced &lt;code&gt;UFCQuadrilateral&lt;/code&gt; and &lt;code&gt;UFCHexahedron&lt;/code&gt;.
The entity dimensions of these new elements are &amp;ldquo;flattened&amp;rdquo; to normal elements.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from FIAT.reference_element import UFCQuadrilateral
quad_cell = UFCQuadrilateral()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;In [..]: quad_cell.get_topology()
Out[..]:
{0: {0: (0,), 1: (1,), 2: (2,), 3: (3,)},
 1: {0: (0, 1), 1: (2, 3), 2: (0, 2), 3: (1, 3)},
 2: {0: (0, 1, 2, 3)}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The tensor product cell can be accessed if needed by &lt;code&gt;quad_cell.product&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Mesh entity description for quadrilateral and hexahedron mesh in FFC and DOLFIN was modified to have the same topology as FIAT&amp;rsquo;s flattened &lt;code&gt;UFCQuadrilateral&lt;/code&gt; and &lt;code&gt;UFCHexahedron&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>First evaluation is passed!</title>
      <link>https://ivanyashchuk.github.io/post/first-evaluation/</link>
      <pubDate>Sun, 02 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ivanyashchuk.github.io/post/first-evaluation/</guid>
      <description>&lt;p&gt;This week was the first evaluation week, which I passed successfully!
So far I&amp;rsquo;ve got a basic working implementation for solving Poisson&amp;rsquo;s equation in 2D.
There are lots of things to improve and develop still, but it was a good start.&lt;/p&gt;

&lt;p&gt;Plan for the future:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Move changes from FFC into one class in FIAT.&lt;/li&gt;
&lt;li&gt;Deal with element entity (vertices and facets) ordering issue (this will fix the DirichletBC issue).&lt;/li&gt;
&lt;li&gt;More unit tests are required.&lt;/li&gt;
&lt;li&gt;Documented demo.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>About Dicrichlet boundary conditions</title>
      <link>https://ivanyashchuk.github.io/post/dirichlet-bc/</link>
      <pubDate>Sun, 25 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ivanyashchuk.github.io/post/dirichlet-bc/</guid>
      <description>&lt;p&gt;Almost all simple problems using Finite Element Method goes down to solving $ \boldsymbol{A} x = \boldsymbol{b} $, where $\boldsymbol{A}$ is the so called stiffness matrix and $\boldsymbol{b}$ is the load vector.
The solution to the problem is not unique untill some boundary condition is specified. The simplest one is the Dirichlet boundary condition.
It specifies the values that a solution needs to take on along the boundary of the domain.
In FEniCS it can be easily specified with &lt;code&gt;DicrichletBC&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bc = DicrichletBC(FunctionSpace, Value, SubDomain)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem is that currently using this line of code sets the boundary value to the wrong places in the domain. Most probably the problem is in the identification of boundary faces of the mesh.
There is probably an assumption that mesh in 2D can be composed out of triangles only and in 3D - tetrahedrons. This should be modified to get the &lt;code&gt;DicrichletBC&lt;/code&gt; to work correctly.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>I attended FEniCS&#39;17!</title>
      <link>https://ivanyashchuk.github.io/post/fenics-conference/</link>
      <pubDate>Sun, 18 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ivanyashchuk.github.io/post/fenics-conference/</guid>
      <description>&lt;p&gt;This week I was at the FEniCS Conference at University of Luxembourg. I got a chance to meet my mentors personally and other members of the FEniCS community as well.&lt;/p&gt;

&lt;p&gt;There were a lot of interesting people and a lot of interesting talks from a diverse range of scientific areas: Software and Algorithms, Magnetics, Optimisation, Biomechanics, Visualisation and Large Scale Computing, Solid and Fluid Mechanics.&lt;/p&gt;

&lt;p&gt;Thanks to my mentors Chris, Jack and Martin for inviting me there!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/1N50uR3RaXy6vqPucpry43vlycvE0BrC9WmoryxvcFtc4tf9GZdw1Jju6Ey8XX9E5_PXdHFy6YOqJssEZ89sTfqlIpvBmPjwtfEVf3tc1bTATHKFLuRcQbO88zBa17F59AQZt2Y=w1059-h794-no&#34;&gt;
&lt;em&gt;Guided walk through Luxembourg&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/s7pfIX46hJWGLfaPFl7fSDakH065hn7i3p8lCgx_UTdA7_viVMYl-_UW7CUW-z4tQOyiF3cg4tdD6jXuxLmfONF1-6MKg1xrYxoHFBs1Y4KjgfMIiRKaMBHTo99Ux1qNBPfrxXo=w1059-h794-no&#34;&gt;
&lt;em&gt;Carl Lundholm from Chalmers is preparing to solve Poisson&amp;rsquo;s equation with Microsoft Hololens&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://files.slack.com/files-pri/T1AFBGYP2-F5SB52WJC/dsc_0208.jpg?pub_secret=1c23ce20bd&#34;&gt;
&lt;em&gt;Some discussions from a parallel GSoC project about XDMF&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>My project description / First nice plot!</title>
      <link>https://ivanyashchuk.github.io/post/project-description/</link>
      <pubDate>Sat, 10 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ivanyashchuk.github.io/post/project-description/</guid>
      <description>&lt;p&gt;&lt;em&gt;Coding period&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The project idea aims at being able to assemble and solve the simplest partial differential equation (PDE), a Poisson&amp;rsquo;s equation $\Delta u = f $, in 2D (quadrilateral mesh) and 3D (hexahedral mesh) in FEniCS.&lt;/p&gt;

&lt;p&gt;One of the first steps in the Finite Element Method (FEM) is splitting the domain on which the PDE is solved into small parts, called cells, which in sum make a mesh.
FEniCS has always supported meshes consisting of simplex cells (e.g. triangles and tetrahedrons), but has limited support for meshes consisting of quadrilateral (quad) and hexahedral (hex) cells.
Finite element problems solved on quad/hex meshes often have better approximation properties and better robustness to cell distortion than those solved on simplex meshes.
Example of the 2D triangular mesh of the unit square:
&lt;html&gt;  &lt;head&gt;    &lt;meta http-equiv=&#34;content-type&#34; content=&#34;text/html;charset=UTF-8&#34; /&gt;    &lt;meta name=&#34;generator&#34; content=&#34;FEniCS/DOLFIN (http://fenicsproject.org)&#34; /&gt;    &lt;title&gt;FEniCS/DOLFIN X3DOM plot&lt;/title&gt;    &lt;script type=&#34;text/javascript&#34; src=&#34;https://www.x3dom.org/download/x3dom.js&#34;&gt;&lt;/script&gt;    &lt;script type=&#34;text/javascript&#34; src=&#34;https://code.jquery.com/jquery-3.1.0.js&#34;&gt;&lt;/script&gt;    &lt;script type=&#34;text/javascript&#34; src=&#34;https://rawgit.com/plscott/fenics-x3dom/master/x3dom_support.js&#34;&gt;&lt;/script&gt;    &lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;https://www.x3dom.org/download/x3dom.css&#34; /&gt;    &lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;https://rawgit.com/plscott/fenics-x3dom/master/x3dom_support.css&#34; /&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;x3d showStat=&#34;false&#34; xmlns=&#34;http://www.web3d.org/specifications/x3d-namespace&#34; width=&#34;500.000000px&#34; height=&#34;400.000000px&#34;&gt;      &lt;scene&gt;        &lt;shape&gt;          &lt;appearance&gt;            &lt;material diffuseColor=&#34;1.000000 1.000000 1.000000&#34; emissiveColor=&#34;0.000000 0.000000 0.000000&#34; specularColor=&#34;0.000000 0.000000 0.000000&#34; ambientIntensity=&#34;0&#34; shininess=&#34;0.5&#34; transparency=&#34;0&#34;&gt;&lt;/material&gt;          &lt;/appearance&gt;          &lt;indexedFaceSet solid=&#34;false&#34; colorPerVertex=&#34;false&#34; coordIndex=&#34;0 4 1 -1 0 4 3 -1 1 5 2 -1 1 5 4 -1 3 7 4 -1 3 7 6 -1 4 8 5 -1 4 8 7 -1 &#34;&gt;            &lt;coordinate point=&#34;0 0 0 0.5 0 0 1 0 0 0 0.5 0 0.5 0.5 0 1 0.5 0 0 1 0 0.5 1 0 1 1 0 &#34;&gt;&lt;/coordinate&gt;          &lt;/indexedFaceSet&gt;        &lt;/shape&gt;        &lt;shape&gt;          &lt;appearance&gt;            &lt;material emissiveColor=&#34;0.000000 0.000000 0.000000&#34; specularColor=&#34;0.000000 0.000000 0.000000&#34; ambientIntensity=&#34;0&#34; shininess=&#34;0.5&#34; transparency=&#34;0&#34;&gt;&lt;/material&gt;          &lt;/appearance&gt;          &lt;indexedLineSet solid=&#34;false&#34; colorPerVertex=&#34;false&#34; coordIndex=&#34;0 1 -1 0 3 -1 0 4 -1 1 2 -1 1 4 -1 1 5 -1 2 5 -1 3 4 -1 3 6 -1 3 7 -1 4 5 -1 4 7 -1 4 8 -1 5 8 -1 6 7 -1 7 8 -1 &#34;&gt;            &lt;coordinate point=&#34;0 0 0 0.5 0 0 1 0 0 0 0.5 0 0.5 0.5 0 1 0.5 0 0 1 0 0.5 1 0 1 1 0 &#34;&gt;&lt;/coordinate&gt;          &lt;/indexedLineSet&gt;        &lt;/shape&gt;        &lt;viewpoint id=&#34;default&#34; position=&#34;1.914214 1.914214 1.414214&#34; orientation=&#34;-0.7071067812 0.7071067812 0 1&#34; fieldOfView=&#34;0.785398&#34; centerOfRotation=&#34;0.500000 0.500000 0.000000&#34; zNear=&#34;-1&#34; zFar=&#34;-1&#34;&gt;&lt;/viewpoint&gt;        &lt;viewpoint id=&#34;top&#34; position=&#34;0.500000 2.500000 0.000000&#34; orientation=&#34;-1 0 0 1.5707963267948&#34; fieldOfView=&#34;0.785398&#34; centerOfRotation=&#34;0.500000 0.500000 0.000000&#34; zNear=&#34;-1&#34; zFar=&#34;-1&#34;&gt;&lt;/viewpoint&gt;        &lt;viewpoint id=&#34;bottom&#34; position=&#34;0.500000 -1.500000 0.000000&#34; orientation=&#34;1 0 0 1.5707963267948&#34; fieldOfView=&#34;0.785398&#34; centerOfRotation=&#34;0.500000 0.500000 0.000000&#34; zNear=&#34;-1&#34; zFar=&#34;-1&#34;&gt;&lt;/viewpoint&gt;        &lt;viewpoint id=&#34;left&#34; position=&#34;2.500000 0.500000 0.000000&#34; orientation=&#34;0 1 0 1.5707963267948&#34; fieldOfView=&#34;0.785398&#34; centerOfRotation=&#34;0.500000 0.500000 0.000000&#34; zNear=&#34;-1&#34; zFar=&#34;-1&#34;&gt;&lt;/viewpoint&gt;        &lt;viewpoint id=&#34;right&#34; position=&#34;-1.500000 0.500000 0.000000&#34; orientation=&#34;0 -1 0 1.5707963267948&#34; fieldOfView=&#34;0.785398&#34; centerOfRotation=&#34;0.500000 0.500000 0.000000&#34; zNear=&#34;-1&#34; zFar=&#34;-1&#34;&gt;&lt;/viewpoint&gt;        &lt;viewpoint id=&#34;back&#34; position=&#34;0.500000 0.500000 -2.000000&#34; orientation=&#34;0 1 0 3.1415926535898&#34; fieldOfView=&#34;0.785398&#34; centerOfRotation=&#34;0.500000 0.500000 0.000000&#34; zNear=&#34;-1&#34; zFar=&#34;-1&#34;&gt;&lt;/viewpoint&gt;        &lt;viewpoint id=&#34;front&#34; position=&#34;0.500000 0.500000 2.000000&#34; orientation=&#34;0 0 0 1&#34; fieldOfView=&#34;0.785398&#34; centerOfRotation=&#34;0.500000 0.500000 0.000000&#34; zNear=&#34;-1&#34; zFar=&#34;-1&#34;&gt;&lt;/viewpoint&gt;        &lt;background skyColor=&#34;0.950000 0.950000 0.950000&#34;&gt;&lt;/background&gt;        &lt;directionalLight ambientIntensity=&#34;0&#34; intensity=&#34;1&#34;&gt;&lt;/directionalLight&gt;      &lt;/scene&gt;    &lt;/x3d&gt;    &lt;div id=&#34;menu&#34;&gt;&lt;form id=&#34;menu-items&#34;&gt;&lt;input type=&#34;radio&#34; id=&#34;button-options&#34; name=&#34;menu&#34; checked=&#34;&#34; /&gt;        &lt;label for=&#34;button-options&#34;&gt;Options&lt;/label&gt;        &lt;input type=&#34;radio&#34; id=&#34;button-summary&#34; name=&#34;menu&#34; /&gt;        &lt;label for=&#34;button-summary&#34; style=&#34;display: none;&#34;&gt;Summary&lt;/label&gt;        &lt;input type=&#34;radio&#34; id=&#34;button-color&#34; name=&#34;menu&#34; /&gt;        &lt;label for=&#34;button-color&#34; style=&#34;display: none;&#34;&gt;Color&lt;/label&gt;        &lt;input type=&#34;radio&#34; id=&#34;button-warp&#34; name=&#34;menu&#34; /&gt;        &lt;label for=&#34;button-warp&#34; style=&#34;display: none;&#34;&gt;Warp&lt;/label&gt;        &lt;input type=&#34;radio&#34; id=&#34;button-viewpoints&#34; name=&#34;menu&#34; /&gt;        &lt;label for=&#34;button-viewpoints&#34; style=&#34;display: none;&#34;&gt;Viewpoints&lt;/label&gt;      &lt;/form&gt;      &lt;div id=&#34;menu-content&#34;&gt;&lt;div id=&#34;content-options&#34; for=&#34;button-options&#34;&gt;&lt;span&gt;Menu Options&lt;/span&gt;          &lt;br /&gt;          &lt;form class=&#34;options&#34;&gt;&lt;input type=&#34;checkbox&#34; id=&#34;select-summary&#34; /&gt;            &lt;label for=&#34;select-summary&#34;&gt;Summary&lt;/label&gt;          &lt;/form&gt;          &lt;br /&gt;          &lt;form class=&#34;options&#34;&gt;&lt;input type=&#34;checkbox&#34; id=&#34;select-color&#34; /&gt;            &lt;label for=&#34;select-color&#34;&gt;Color&lt;/label&gt;          &lt;/form&gt;          &lt;br /&gt;          &lt;form class=&#34;options&#34;&gt;&lt;input type=&#34;checkbox&#34; id=&#34;select-warp&#34; /&gt;            &lt;label for=&#34;select-warp&#34;&gt;Warp&lt;/label&gt;          &lt;/form&gt;          &lt;br /&gt;          &lt;form class=&#34;options&#34;&gt;&lt;input type=&#34;checkbox&#34; id=&#34;select-viewpoints&#34; /&gt;            &lt;label for=&#34;select-viewpoints&#34;&gt;Viewpoints&lt;/label&gt;          &lt;/form&gt;        &lt;/div&gt;        &lt;div id=&#34;content-summary&#34; for=&#34;button-summary&#34; hidden=&#34;&#34;&gt;Number of vertices: 9&lt;br /&gt;Number of cells: 8&lt;/div&gt;        &lt;div id=&#34;content-color&#34; for=&#34;button-color&#34; hidden=&#34;&#34;&gt;&lt;form&gt;            &lt;input id=&#34;color-checkbox&#34; type=&#34;checkbox&#34; checked=&#34;&#34; /&gt;            &lt;label for=&#34;color-checkbox&#34;&gt;Show Color&lt;/label&gt;          &lt;/form&gt;Current Color Map:&lt;br /&gt;          &lt;span id=&#34;min-color-value&#34;&gt;&lt;/span&gt;          &lt;span id=&#34;color-map&#34;&gt;&lt;/span&gt;          &lt;span id=&#34;max-color-value&#34;&gt;&lt;/span&gt;        &lt;/div&gt;        &lt;div id=&#34;content-warp&#34; for=&#34;button-warp&#34; hidden=&#34;&#34;&gt;&lt;form&gt;            &lt;input id=&#34;warp-checkbox&#34; type=&#34;checkbox&#34; /&gt;            &lt;label for=&#34;warp-checkbox&#34;&gt;Warp By Scalar&lt;/label&gt;            &lt;br /&gt;            &lt;input id=&#34;warp-slider&#34; type=&#34;range&#34; min=&#34;0&#34; max=&#34;5&#34; step=&#34;0.01&#34; value=&#34;1&#34; disabled=&#34;&#34; /&gt;            &lt;br /&gt;            &lt;label id=&#34;warp-slider-val&#34; for=&#34;warp-slider&#34;&gt;1&lt;/label&gt;          &lt;/form&gt;        &lt;/div&gt;        &lt;div id=&#34;content-viewpoints&#34; for=&#34;button-viewpoints&#34; hidden=&#34;&#34;&gt;&lt;span&gt;Viewpoint Options&lt;/span&gt;          &lt;br /&gt;          &lt;button class=&#34;viewpoint&#34;&gt;front&lt;/button&gt;          &lt;button class=&#34;viewpoint&#34;&gt;back&lt;/button&gt;          &lt;button class=&#34;viewpoint&#34;&gt;left&lt;/button&gt;          &lt;br /&gt;          &lt;button class=&#34;viewpoint&#34;&gt;right&lt;/button&gt;          &lt;button class=&#34;viewpoint&#34;&gt;top&lt;/button&gt;          &lt;button class=&#34;viewpoint&#34;&gt;bottom&lt;/button&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;&lt;/p&gt;

&lt;p&gt;So far I have managed to get the solution of the Poisson&amp;rsquo;s equation (considering simple case $f=1$ and zero Dirichlet condition on one of the edges) on the unit square quadrilateral mesh.
Next step to accomplish is interpolating and projecting a function into the function space associated with the quadrilateral mesh.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Coding period started</title>
      <link>https://ivanyashchuk.github.io/post/coding-period-started/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ivanyashchuk.github.io/post/coding-period-started/</guid>
      <description>&lt;p&gt;&lt;em&gt;Coding period&lt;/em&gt; has officially started on 30th of May!&lt;/p&gt;

&lt;p&gt;For the first week, my goal is to be able to solve $ \int_\Omega 1 \, d\Omega $ when $\Omega$, which is some domain in $\mathbb{R}^2$ or $\mathbb{R}^3$, consists of quadrilateral or hexahedral cells.
This simple thing of computing the area (or volume) is one of the essential part to make Finite Element Method working. It gives the ratio between the reference (local) cell (which has predefined dimensions) and the
arbitrary (global) cell.&lt;/p&gt;

&lt;p&gt;In FEniCS $ \int_\Omega 1 \, d\Omega $ corresponds to the following python code snippet&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Importing FEniCS components
from fenics import *
# Creating unit square domain devided into 1 x 1 cells
mesh = UnitQuadMesh(mpi_comm_self(), 1, 1)
# Assembling the expression
assemble(1.0 * dx(mesh))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should return the area (or volume) of the domain, which is $1.0$ in case of unit square or unit cube.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Second meeting with my mentors</title>
      <link>https://ivanyashchuk.github.io/post/second-meeting/</link>
      <pubDate>Tue, 16 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ivanyashchuk.github.io/post/second-meeting/</guid>
      <description>&lt;p&gt;&lt;em&gt;Community bonding period&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Today I had another video meetings: first with Chris, then with Martin.
We have discussed with Chris importance of communication, asking questions and recording my experience through the blog.
Martin explained in details the structure of Uflacs (one of the key components in FEniCS).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>First meeting with my mentors</title>
      <link>https://ivanyashchuk.github.io/post/first-meeting/</link>
      <pubDate>Thu, 11 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ivanyashchuk.github.io/post/first-meeting/</guid>
      <description>&lt;p&gt;&lt;em&gt;Community bonding period&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;On 9th of May I had a hangouts meeting with my mentors: Chris Richardson from Cambridge, Martin Alnæs from Oslo and Jack Hale from Luxembourg.
We introduced ourselves to each other and discussed how I managed to find this program and why I chose FEniCS to work on (because I thought it certainly going to be a great experience :) ).
There is a slack channel for FEniCS developers and we decided to have our written discussions there.&lt;/p&gt;

&lt;p&gt;Also my mentors kindly invited me to attent the FEniCS 2017 Conference which will take place in Luxembourg in June. I am very grateful!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Accepted to GSoC</title>
      <link>https://ivanyashchuk.github.io/post/welcome-to-gsoc/</link>
      <pubDate>Sat, 06 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ivanyashchuk.github.io/post/welcome-to-gsoc/</guid>
      <description>&lt;p&gt;Hello!&lt;/p&gt;

&lt;p&gt;I was officially accepted to the Google Summer of Code 2017 program. Excited for working with FEniCS Project this summer as a GSoC student&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ru&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Really happy to announce our first ever &lt;a href=&#34;https://twitter.com/hashtag/GSOC2017?src=hash&#34;&gt;#GSOC2017&lt;/a&gt; students to work on &lt;a href=&#34;https://twitter.com/hashtag/FEniCS?src=hash&#34;&gt;#FEniCS&lt;/a&gt;: Ivan Yashchuk and Michal Habera. Thanks &lt;a href=&#34;https://twitter.com/gsoc&#34;&gt;@gsoc&lt;/a&gt; and &lt;a href=&#34;https://twitter.com/NumFOCUS&#34;&gt;@NumFOCUS&lt;/a&gt;.&lt;/p&gt;&amp;mdash; FEniCS Project (@fenicsproject) &lt;a href=&#34;https://twitter.com/fenicsproject/status/860503927615311873&#34;&gt;5 мая 2017 г.&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>